<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Project Euler</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="euler.css" type="text/css" />
</head>
<body>
<h1 id="project-euler">Project Euler</h1><blockquote><p>Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems. — <a href="http://projecteuler.net">Project Euler</a></p></blockquote><p>Follows is my attempt at the problems. My goal in writing this is threefold: to improve my familiarity with the Haskell language, work on my algorithmic chops, and further my technical writing skills.</p><p>I presume a basic understanding of Haskell, but not in any of the algorithmic techniques. Each solution should be comprehensible without former exposure to the problem. If you are unfamiliar with Haskell, you may still be able to follow along as many of the solutions are quite expressive — hopefully this will pique your interest in the language!</p><p>This treatise is written in Literate Haskell, meaning it is executable as-is with <code>ghc</code>. The <a href="https://github.com/xaviershay/project-euler">source is available on GitHub</a>.</p><h2 id="preamble">Preamble</h2><p>All imports are required to be at the top of the source file, so they are presented here and not duplicated in the problems for which they are specifically required. I restrict myself to common packages.</p><p>Both sample input and expected answers (after they have been solved) will be expressed as HUnit tests below each solution.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Test</span><span class='hs-varop'>.</span><span class='hs-conid'>HUnit</span>
</pre>
<p>Importing the suite of <code>List</code> functions is non-controversial in a language that specifically excels at list processing.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>List</span>
<span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span><span class='hs-varop'>.</span><span class='hs-conid'>Split</span>
</pre>
<p>The <code>Char</code> module is included for conversion functions handy for dealing with different input and output formats of the problems, specifically <code>digitToInt</code> to convert strings to integers.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Char</span>
</pre>
<p>Lookup tables are a useful optimization for some of the problems. Since the function names in <code>Data.Map</code> conflict with many of the functions in the <code>Prelude</code>, requrie the <code>M</code> prefix to reference them.</p><pre><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>M</span>
</pre>
<p>A helper function similar to <code>digitToInt</code> for use in parsing input.</p><pre><span class='hs-definition'>stringToInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>stringToInt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>read</span>
</pre>

<h2 id="problem-1">Problem 1</h2><blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote><p>Haskell allows an expressive solution to this problem. The only novelty is the use of <code>nub</code>, a built in function for removing duplicates from an array, the distinct naming of which I haven’t seen elsewhere.</p><pre><span class='hs-definition'>euler1</span> <span class='hs-varid'>max</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>nub</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>multiplesOf</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-varid'>multiplesOf</span> <span class='hs-num'>5</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>multiplesOf</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-varop'>*</span><span class='hs-num'>2</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>max</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests1</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#1 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>23</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler1</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#1 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>233168</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler1</span> <span class='hs-num'>1000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-2">Problem 2</h2><blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p></blockquote><p>Start by defining an infinite sequence to generate Fibonacci values, a particularly elegant operation in Haskell.</p><pre><span class='hs-definition'>fibonacci</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seq</span> <span class='hs-num'>0</span> <span class='hs-num'>1</span> <span class='hs-keyword'>where</span> <span class='hs-varid'>seq</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-varop'>+</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>seq</span> <span class='hs-varid'>y</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-varop'>+</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p>With this definition, an expressive solution is once again possible.</p><pre><span class='hs-definition'>euler2</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>even</span> <span class='hs-varop'>.</span> <span class='hs-varid'>takeWhile</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;=</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fibonacci</span>
</pre>


<pre><span class='hs-definition'>tests2</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#2 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>44</span>      <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler2</span> <span class='hs-num'>40</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#2 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>4613732</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler2</span> <span class='hs-num'>4000000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-3">Problem 3</h2><blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143?</p></blockquote><p>Starting from two and working up, dividing the target by found factors on the way, any found factors will necessarily be prime: 4 will not be found because 2 would have already been found twice.</p><pre><span class='hs-definition'>primeFactors</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n</span> <span class='hs-num'>2</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>p</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n'</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>p</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>n'</span> <span class='hs-varop'>`div`</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n'</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
</pre>
<p>The solution is then the last factor found. Note that no explicit logic for “primeness” is required.</p><pre><span class='hs-definition'>euler3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>last</span> <span class='hs-varop'>.</span> <span class='hs-varid'>primeFactors</span>
</pre>


<pre><span class='hs-definition'>tests3</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#3 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>29</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler3</span> <span class='hs-num'>13195</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#3 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>6857</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler3</span> <span class='hs-num'>600851475143</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-4">Problem 4</h2><blockquote><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is<br />91 × 99 = 9009.</p><p>Find the largest palindrome made from the product of two 3-digit numbers.</p></blockquote><p>The easiest palindrome check is a string comparison between the number and its reversed form.</p><pre><span class='hs-definition'>palindrome</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>x'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>x'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>x'</span>
</pre>
<p>Since the input set is relatively small, it would suffice to generate a list of all possible numbers and filter them. This can generate a solution on my machine in approximately two seconds. The search space can be reduced dramatically, however, with two techniques.</p><p>It is known that the answer will be six digits long (maximum length of two 3-digit numbers multiplied), and will be of the form:</p><blockquote><p>= 100000<i>a</i> + 10000<i>b</i> + 1000<i>c</i> + 100<i>c</i> + 10<i>b</i> + <i>a</i><br /> = 100001<i>a</i> + 10010<i>b</i> + 1100<i>c</i><br /> = 11(9091<i>a</i> + 910<i>b</i> + 110<i>c</i>)<br /></p></blockquote><p>This informs us that the answer must be divisible by 11, which allows the input set to be trimmed considerably, yielding an order of magnitude speed up.</p><p>Intuitively, the answer will be the product of two digits greater than nine hundred, which allows us to scope the search space even further. While this may be presumptious, if no solution is found it is easy enough to drop the lower bound.</p><pre><span class='hs-definition'>euler4</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varid'>palindromes</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>palindromes</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-varop'>*</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-layout'>,</span> <span class='hs-varid'>palindrome</span> <span class='hs-varop'>$</span> <span class='hs-varid'>x</span> <span class='hs-varop'>*</span> <span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span>
    <span class='hs-varid'>ys</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>y</span> <span class='hs-num'>11</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests4</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#4 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>9009</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler4</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>90</span><span class='hs-keyglyph'>..</span><span class='hs-num'>99</span><span class='hs-keyglyph'>]</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#4 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>906609</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler4</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>900</span><span class='hs-keyglyph'>..</span><span class='hs-num'>999</span><span class='hs-keyglyph'>]</span>
  <span class='hs-keyglyph'>]</span>
</pre>

<h2 id="problem-5">Problem 5</h2><blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p></blockquote><p>Using the built-in <code>lcm</code> function is arguably cheating, but as the prime-factoring basis of the algorithm has already be written in problem three, I feel it is allowable.</p><pre><span class='hs-definition'>euler5</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl1</span> <span class='hs-varid'>lcm</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests5</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#5 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>2520</span>      <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler5</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#5 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>232792560</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler5</span> <span class='hs-num'>20</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-6">Problem 6</h2><blockquote><p>The sum of the squares of the first ten natural numbers is:</p><p>1<sup>2</sup> + 2<sup>2</sup> + … + 10<sup>2</sup> = 385</p><p>The square of the sum of the first ten natural numbers is:</p><p>(1 + 2 + … + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</p><p>The difference between the two is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote><p>The problem translates naturally into code.</p><pre><span class='hs-definition'>euler6</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-varop'>^</span><span class='hs-num'>2</span> <span class='hs-comment'>-</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varop'>^</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests6</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#6 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>2640</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler6</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#6 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>25164150</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler6</span> <span class='hs-num'>100</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<p>There is alternative algebraic solution that relies on knowing that the sum of the first <em>n</em> natural numbers is <em>n</em>(<em>n</em>+1)/2 and that the sum of the first <em>n</em> squares is <em>n</em>(<em>n</em>+1)(2<i>n</i>+1)/6. These are both easy to prove by induction, but I wasn’t able to derive them myself.</p><h2 id="problem-7">Problem 7</h2><blockquote><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6<sup>th</sup> prime is 13.</p><p>What is the 10,001<sup>st</sup> prime number?</p></blockquote><p>Having read the <a href="http://www.haskell.org/haskellwiki/Prime_numbers">Haskell wiki page on prime generation</a> a few times, I cheated and nabbed an algorithm with a good trade-off between readability and efficiency (“Optimal trial divison”).</p><p>It works by dividing each new candidate number by every prime generated so far that is less than the square root of the number. If none divide evenly into the number, then the number is prime. Non-prime divisors do not need to be checked since they themselves would have had a prime factor which has already been tested.</p><pre><span class='hs-definition'>coprime</span> <span class='hs-varid'>factors</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>p</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-varop'>*</span><span class='hs-varid'>p</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>rem</span> <span class='hs-varid'>n</span> <span class='hs-varid'>p</span> <span class='hs-varop'>/=</span> <span class='hs-num'>0</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span> <span class='hs-varid'>factors</span>
</pre>


<pre><span class='hs-definition'>primes</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-conop'>:</span> <span class='hs-num'>3</span> <span class='hs-conop'>:</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>coprime</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tail</span> <span class='hs-varid'>primes</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>5</span><span class='hs-layout'>,</span><span class='hs-num'>7</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>euler7</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-varop'>.</span> <span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>primes</span>
</pre>


<pre><span class='hs-definition'>tests7</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#7 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>13</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler7</span> <span class='hs-num'>6</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#7 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>104743</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler7</span> <span class='hs-num'>10001</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-8">Problem 8</h2><blockquote><p>Find the greatest product of five consecutive digits in the 1000-digit number given below.</p></blockquote><pre><span class='hs-definition'>number</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-str'>"73167176531330624919225119674426574742355349194934"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"96983520312774506326239578318016984801869478851843"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"85861560789112949495459501737958331952853208805511"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"12540698747158523863050715693290963295227443043557"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"66896648950445244523161731856403098711121722383113"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"62229893423380308135336276614282806444486645238749"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"30358907296290491560440772390713810515859307960866"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"70172427121883998797908792274921901699720888093776"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"65727333001053367881220235421809751254540594752243"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"52584907711670556013604839586446706324415722155397"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"53697817977846174064955149290862569321978468622482"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"83972241375657056057490261407972968652414535100474"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"82166370484403199890008895243450658541227588666881"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"16427171479924442928230863465674813919123162824586"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"17866458359124566529476545682848912883142607690042"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"24219022671055626321111109370544217506941658960408"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"07198403850962455444362981230987879927244284909188"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"84580156166097919133875499200524063689912560717606"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"05886116467109405077541002256983155200055935729725"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"71636269561882670428252483600823257530420752963450"</span>
</pre>
<p>My first solution used a cumbersome arrangement of <code>splitAt</code> calls to compute a list of all consecutive numbers. I was then made aware of the <code>tails</code> function, which when combined with <code>take 5</code> does essentially the same thing. It does return sequences of less than five digits (from the end of the string), but these do not need to be filtered since their product will never be more than the same string with an extra preceeding digit.</p><pre><span class='hs-definition'>euler8</span> <span class='hs-varid'>input</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>product</span> <span class='hs-varop'>.</span> <span class='hs-varid'>take</span> <span class='hs-num'>5</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tails</span> <span class='hs-varop'>$</span> <span class='hs-varid'>digits</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>digits</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>digitToInt</span> <span class='hs-varid'>input</span>
</pre>


<pre><span class='hs-definition'>tests8</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#8 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>40824</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler8</span> <span class='hs-varid'>number</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-9">Problem 9</h2><blockquote><p>A Pythagorean triplet is a set of three natural numbers, <i>a</i> &lt; <i>b</i> &lt; <i>c</i>, for which <i>a</i><sup>2</sup> + <i>b</i><sup>2</sup> = <i>c</i><sup>2</sup>.</p><p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.</p><p>There exists exactly one Pythagorean triplet for which <i>a</i> + <i>b</i> + <i>c</i> = 1000. Find the product <i>abc</i>.</p></blockquote><p>Using a brute force method, the inner loop is over values of <em>b</em>. It therefore makes sense to optimize that loop by bounding the range to consider as much as possible. The lower bound is obvious since <em>a</em> &lt; <em>b</em>. A naive upper bound is 1000 - <em>a</em> - <em>a</em>, since <em>b</em> &gt; <em>a</em>, <em>c</em> &gt; <em>a</em>, and the sum of all three must equal 1000. Considering also that <em>c</em> &gt; <em>b</em> however allows us to further eliminate the top half of the range.</p><pre><span class='hs-definition'>maxB</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>`div`</span> <span class='hs-num'>2</span>
</pre>


<pre><span class='hs-definition'>euler9</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-varop'>*</span><span class='hs-varid'>b</span><span class='hs-varop'>*</span><span class='hs-varid'>c</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>
                         <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>maxB</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>
                         <span class='hs-keyword'>let</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-comment'>-</span> <span class='hs-varid'>b</span> <span class='hs-comment'>-</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span>
                         <span class='hs-varid'>a</span> <span class='hs-varop'>*</span> <span class='hs-varid'>a</span> <span class='hs-varop'>+</span> <span class='hs-varid'>b</span> <span class='hs-varop'>*</span> <span class='hs-varid'>b</span> <span class='hs-varop'>==</span> <span class='hs-varid'>c</span> <span class='hs-varop'>*</span> <span class='hs-varid'>c</span>
                <span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests9</span> <span class='hs-keyglyph'>=</span>
 <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#9 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>60</span>       <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler9</span> <span class='hs-num'>12</span>
 <span class='hs-layout'>,</span> <span class='hs-str'>"#9 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>31875000</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler9</span> <span class='hs-num'>1000</span>
 <span class='hs-keyglyph'>]</span>
</pre>
<p>For a brute force method that naturally maps to the problem description this solution isn’t bad. Substitution and rearranging of the equations can lead to better lower and upper bounds for the search space, but this is merely a refinement of the same algorithm. There is a more elegant algorithmic approach, however.</p><p><a href="http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple">Euclid’s formula</a> states that for all Pythagorean triples the following hold true where <em>m</em> and <em>n</em> are positive integers:</p><blockquote><p><i>a</i> = <i>m</i><sup>2</sup> - <i>n</i><sup>2</sup><br /> <i>b</i> = 2<i>mn</i><br /> <i>c</i> = <i>m</i><sup>2</sup> + <i>n</i><sup>2</sup><br /></p></blockquote><p>This allows the problem equation to be simplified radically.</p><blockquote><p>(<i>m</i><sup>2</sup> - <i>n</i><sup>2</sup>) + 2<i>mn</i> + (<i>m</i><sup>2</sup> + <i>n</i><sup>2</sup>) = 1000<br /> <i>m</i><sup>2</sup> + <i>mn</i> = 500<br /> <i>m</i>(<i>m</i> + <i>n</i>) = 500<br /></p></blockquote><p>A solution can then be found by finding two matching candidates from the factors of 500, in this case <i>m</i> = 20, <i>n</i> = 5.</p><h2 id="problem-10">Problem 10</h2><blockquote><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p><p>Find the sum of all the primes below two million.</p></blockquote><p>Re-uses the <code>primes</code> function defined in problem seven. Takes a while, but gets there in the end.</p><pre><span class='hs-definition'>euler10</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>takeWhile</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>primes</span>
</pre>


<pre><span class='hs-definition'>tests10</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#10 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>17</span>           <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler10</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#10 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>142913828922</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler10</span> <span class='hs-num'>2000000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-11">Problem 11</h2><blockquote><p>In the 20 × 20 grid below, what is the greatest product of four adjacent numbers in a straight line in any direction (up, down, left, right, or diagonally)?</p></blockquote><pre><span class='hs-definition'>grid11</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-str'>"08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48 "</span>
</pre>
<p>There is no shortcut method to calculating the greatest product for this problem, so a search is in order. The difficulty is in enumerating all of the candidates. If you are not familiar with <a href="http://www.haskell.org/haskellwiki/Pointfree">pointfree style</a>, this solution is going to be a baptism of fire!</p><pre><span class='hs-definition'>euler11</span> <span class='hs-varid'>w</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>product</span> <span class='hs-varop'>.</span> <span class='hs-varid'>candidates</span>
 <span class='hs-keyword'>where</span>
   <span class='hs-varid'>candidates</span> <span class='hs-varid'>input</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-layout'>(</span><span class='hs-varid'>parse</span> <span class='hs-varid'>input</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>directions</span>
</pre>
<p>The algorithm provides separate methods to enumerate candidates for each of the four directions. The other four directions are equivalent and do not need to be considered.</p><pre>   <span class='hs-varid'>directions</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>east</span><span class='hs-layout'>,</span> <span class='hs-varid'>southEast</span><span class='hs-layout'>,</span> <span class='hs-varid'>south</span><span class='hs-layout'>,</span> <span class='hs-varid'>southWest</span><span class='hs-keyglyph'>]</span>
</pre>
<p><code>adjacent</code> will calculate all possible sublists of the grid that can be formed by starting at each cell and walking <code>l</code> cells in the given direction.</p><pre>   <span class='hs-varid'>adjacent</span> <span class='hs-varid'>grid</span> <span class='hs-varid'>direction</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-varop'>.</span> <span class='hs-varid'>direction</span> <span class='hs-varop'>$</span> <span class='hs-varid'>grid</span>
</pre>
<p>East is the simplest direction. For each row in the grid, generate the tails and take the first four of each. As in problem eight, candidates less than the required length do not need to be filtered since they cannot possibly provide an incorrect answer, and add only a neglible amount to the running time.</p><pre>   <span class='hs-varid'>east</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tails</span><span class='hs-layout'>)</span>
</pre>
<p>South is exactly the same logic as east, except with rows and columns switched.</p><pre>   <span class='hs-varid'>south</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>east</span> <span class='hs-varop'>.</span> <span class='hs-varid'>transpose</span>
</pre>
<p>A cute functional trick is used to extract the diagonals from a grid. <code>zipWith</code> shears off the south-west half of the grid, leaving the columns of the resulting half-grid representing the diagonals. <code>transpose</code> makes them into the rows.</p><pre>   <span class='hs-varid'>diagonals</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>transpose</span> <span class='hs-varop'>.</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>drop</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
</pre>
<p>This is not sufficient however. Diagonals from the excluded south-west half still need to be included as candidates! To compensate, a series of subgrids is created each with the top row of the last grid dropped, and diagonals are generated for each of them. Note that <code>tails</code> here is being applied to the grid, not the rows of the grid as it was above.</p><pre>   <span class='hs-varid'>southEast</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>diagonals</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tails</span>
</pre>
<p>South-west has a similar relationship to south-east as south does to east.</p><pre>   <span class='hs-varid'>southWest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>southEast</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>reverse</span>
</pre>
<p>Parsing is the least interesting part of the solution, so has been relegated to the bottom of the definition.</p><pre>   <span class='hs-varid'>parse</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>chunk</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>stringToInt</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>chunk</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>tests11</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#11 test"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>70600674</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler11</span> <span class='hs-num'>20</span> <span class='hs-num'>4</span> <span class='hs-varid'>grid11</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="epilogue">Epilogue</h2><p>There are over three hundred and fifty problems current on Project Euler, and I have as yet tackled but a small sample of them. In time, I hope this corpus will become fuller.</p><p>As a final and closing convenience, a main function is provided to run all the given test cases.</p><pre><span class='hs-definition'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runTestTT</span> <span class='hs-varop'>$</span> <span class='hs-conid'>TestList</span> <span class='hs-layout'>(</span> <span class='hs-varid'>tests1</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests2</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests3</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests4</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests5</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests6</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests7</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests8</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests9</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests10</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests11</span>
                            <span class='hs-layout'>)</span>
</pre>

</body>
</html>
