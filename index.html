<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Project Euler</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="euler.css" type="text/css" />
</head>
<body>
<h1 id="project-euler">Project Euler</h1><blockquote><p>Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems. — <a href="http://projecteuler.net">Project Euler</a></p></blockquote><p>Follows is my attempt at the problems. My goal in writing this is threefold: to improve my familiarity with the Haskell language, work on my algorithmic chops, and further my technical writing skills.</p><p>I presume a basic understanding of Haskell, but not in any of the algorithmic techniques. Each solution should be comprehensible without former exposure to the problem. If you are unfamiliar with Haskell, you may still be able to follow along as many of the solutions are quite expressive — hopefully this will pique your interest in the language!</p><p>This treatise is written in Literate Haskell, meaning it is executable as-is with <code>ghc</code>. The <a href="https://github.com/xaviershay/project-euler">source is available on GitHub</a>.</p><h2 id="preamble">Preamble</h2><p>All imports are required to be at the top of the source file, so they are presented here and not duplicated in the problems for which they are specifically required. I restrict myself to common packages.</p><p>Both sample input and expected answers (after they have been solved) will be expressed as HUnit tests below each solution.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Test</span><span class='hs-varop'>.</span><span class='hs-conid'>HUnit</span>
</pre>
<p>Importing the suite of <code>List</code> functions is non-controversial in a language that specifically excels at list processing.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>List</span>
</pre>
<p>The <code>Char</code> module is included for conversion functions handy for dealing with different input and output formats of the problems, specifically <code>digitToInt</code> to convert strings to integers.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Char</span>
</pre>

<h2 id="problem-1">Problem 1</h2><blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote><p>Haskell allows an expressive solution to this problem. The only novelty is the use of <code>nub</code>, a built in function for removing duplicates from an array, the distinct naming of which I haven’t seen elsewhere.</p><pre><span class='hs-definition'>euler1</span> <span class='hs-varid'>max</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>nub</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>multiplesOf</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-varid'>multiplesOf</span> <span class='hs-num'>5</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>multiplesOf</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-varop'>*</span><span class='hs-num'>2</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>max</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests1</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#1 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>23</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler1</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#1 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>233168</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler1</span> <span class='hs-num'>1000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-2">Problem 2</h2><blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p></blockquote><p>Start by defining an infinite sequence to generate Fibonacci values, a particularly elegant operation in Haskell.</p><pre><span class='hs-definition'>fibonacci</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seq</span> <span class='hs-num'>0</span> <span class='hs-num'>1</span> <span class='hs-keyword'>where</span> <span class='hs-varid'>seq</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-varop'>+</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>seq</span> <span class='hs-varid'>y</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-varop'>+</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p>With this definition, an expressive solution is once again possible.</p><pre><span class='hs-definition'>euler2</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>even</span> <span class='hs-varop'>.</span> <span class='hs-varid'>takeWhile</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;=</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fibonacci</span>
</pre>


<pre><span class='hs-definition'>tests2</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#2 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>44</span>      <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler2</span> <span class='hs-num'>40</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#2 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>4613732</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler2</span> <span class='hs-num'>4000000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-3">Problem 3</h2><blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143?</p></blockquote><p>Starting from two and working up, dividing the target by found factors on the way, any found factors will necessarily be prime: 4 will not be found because 2 would have already been found twice.</p><pre><span class='hs-definition'>primeFactors</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n</span> <span class='hs-num'>2</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>p</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n'</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>p</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>n'</span> <span class='hs-varop'>`div`</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n'</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
</pre>
<p>The solution is then the last factor found. Note that no explicit logic for “primeness” is required.</p><pre><span class='hs-definition'>euler3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>last</span> <span class='hs-varop'>.</span> <span class='hs-varid'>primeFactors</span>
</pre>


<pre><span class='hs-definition'>tests3</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#3 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>29</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler3</span> <span class='hs-num'>13195</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#3 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>6857</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler3</span> <span class='hs-num'>600851475143</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-4">Problem 4</h2><blockquote><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 91 × 99 = 9009.</p><p>Find the largest palindrome made from the product of two 3-digit numbers.</p></blockquote><p>The easiest palindrome check is a string comparison between the number and its reversed form.</p><pre><span class='hs-definition'>palindrome</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>x'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>x'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>x'</span>
</pre>
<p>Since the input set is relatively small, it would suffice to generate a list of all possible numbers and filter them. This can generate a solution on my machine in approximately two seconds. The search space can be reduced dramatically, however, with two techniques.</p><p>It is known that the answer will be six digits long (maximum length of two 3-digit numbers multiplied), and will be of the form:</p><pre><code>  100000a + 10000b + 1000c + 100c + 10b + a
= 100001a + 10010b + 1100c
= 11(9091a + 910b + 110c)
</code></pre><p>This informs us that the answer must be divisible by 11, which allows the input set to be trimmed considerably, yielding an order of magnitude speed up.</p><p>Intuitively, the answer will be the product of two digits greater than nine hundred, which allows us to scope the search space even further. While this may be presumptious, if no solution is found it is easy enough to drop the lower bound.</p><pre><span class='hs-definition'>euler4</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varid'>palindromes</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>palindromes</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-varop'>*</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-layout'>,</span> <span class='hs-varid'>palindrome</span> <span class='hs-varop'>$</span> <span class='hs-varid'>x</span> <span class='hs-varop'>*</span> <span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span>
    <span class='hs-varid'>ys</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>y</span> <span class='hs-num'>11</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests4</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#4 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>9009</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler4</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>90</span><span class='hs-keyglyph'>..</span><span class='hs-num'>99</span><span class='hs-keyglyph'>]</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#4 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>906609</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler4</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>900</span><span class='hs-keyglyph'>..</span><span class='hs-num'>999</span><span class='hs-keyglyph'>]</span>
  <span class='hs-keyglyph'>]</span>
</pre>

<h2 id="problem-5">Problem 5</h2><blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p></blockquote><p>Using the built-in <code>lcm</code> function is arguably cheating, but as we have already written the prime-factoring basis of the algorithm in problem three, I feel it is allowable.</p><pre><span class='hs-definition'>euler5</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr1</span> <span class='hs-varid'>lcm</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests5</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#5 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>2520</span>      <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler5</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#5 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>232792560</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler5</span> <span class='hs-num'>20</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-6">Problem 6</h2><blockquote><p>The sum of the squares of the first ten natural numbers is:</p><p>1<sup>2</sup> + 2<sup>2</sup> + … + 10<sup>2</sup> = 385</p><p>The square of the sum of the first ten natural numbers is:</p><p>(1 + 2 + … + 10)^2 = 55<sup>2</sup> = 3025</p><p>The difference between the two is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote><p>The problem translates naturally into code.</p><pre><span class='hs-definition'>euler6</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-varop'>^</span><span class='hs-num'>2</span> <span class='hs-comment'>-</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varop'>^</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests6</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#6 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>2640</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler6</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#6 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>25164150</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler6</span> <span class='hs-num'>100</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<p>There is alternative algebraic solution that relies on knowing that the sum of the first <code>n</code> natural numbers is <code>n(n+1)/2</code> and that the sum of the first <code>n</code> squares is <code>n(n+1)(2n+1)/6</code>. These are both easy to prove by induction, but I wasn’t able to derive them myself.</p><h2 id="problem-7">Problem 7</h2><blockquote><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6<sup>th</sup> prime is 13.</p><p>What is the 10,001<sup>st</sup> prime number?</p></blockquote><p>Having read the <a href="http://www.haskell.org/haskellwiki/Prime_numbers">Haskell wiki page on prime generation</a> a few times, I cheated and nabbed an algorithm with a good trade-off between readability and efficiency (“Optimal trial divison”).</p><p>It works by dividing each new candidate number by every prime generated so far that is less than the square root of the number. If none divide evenly into the number, then the number is prime. Non-prime divisors do not need to be checked since they themselves would have had a prime factor which has already been tested.</p><pre><span class='hs-definition'>coprime</span> <span class='hs-varid'>factors</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>p</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-varop'>*</span><span class='hs-varid'>p</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>rem</span> <span class='hs-varid'>n</span> <span class='hs-varid'>p</span> <span class='hs-varop'>/=</span> <span class='hs-num'>0</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span> <span class='hs-varid'>factors</span>
</pre>


<pre><span class='hs-definition'>primes</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-conop'>:</span> <span class='hs-num'>3</span> <span class='hs-conop'>:</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>coprime</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tail</span> <span class='hs-varid'>primes</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>5</span><span class='hs-layout'>,</span><span class='hs-num'>7</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>euler7</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-varop'>.</span> <span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>primes</span>
</pre>


<pre><span class='hs-definition'>tests7</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#7 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>13</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler7</span> <span class='hs-num'>6</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#7 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>104743</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler7</span> <span class='hs-num'>10001</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-8">Problem 8</h2><blockquote><p>Find the greatest product of five consecutive digits in the 1000-digit number given below.</p></blockquote><pre><span class='hs-definition'>number</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-str'>"73167176531330624919225119674426574742355349194934"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"96983520312774506326239578318016984801869478851843"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"85861560789112949495459501737958331952853208805511"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"12540698747158523863050715693290963295227443043557"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"66896648950445244523161731856403098711121722383113"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"62229893423380308135336276614282806444486645238749"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"30358907296290491560440772390713810515859307960866"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"70172427121883998797908792274921901699720888093776"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"65727333001053367881220235421809751254540594752243"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"52584907711670556013604839586446706324415722155397"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"53697817977846174064955149290862569321978468622482"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"83972241375657056057490261407972968652414535100474"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"82166370484403199890008895243450658541227588666881"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"16427171479924442928230863465674813919123162824586"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"17866458359124566529476545682848912883142607690042"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"24219022671055626321111109370544217506941658960408"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"07198403850962455444362981230987879927244284909188"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"84580156166097919133875499200524063689912560717606"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"05886116467109405077541002256983155200055935729725"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"71636269561882670428252483600823257530420752963450"</span>
</pre>
<p>My first solution used a cumbersome arrangement of <code>splitAt</code> calls to compute a list of all consecutive numbers. I was then made aware of the <code>tails</code> function, which when combined with <code>take 5</code> does essentially the same thing. It does return sequences of less than five digits (from the end of the string), but these do not need to be filtered since their product will never be more than the same string with an extra preceeding digit.</p><pre><span class='hs-definition'>euler8</span> <span class='hs-varid'>input</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>product</span> <span class='hs-varop'>.</span> <span class='hs-varid'>take</span> <span class='hs-num'>5</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tails</span> <span class='hs-varop'>$</span> <span class='hs-varid'>digits</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>digits</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>digitToInt</span> <span class='hs-varid'>input</span>
</pre>


<pre><span class='hs-definition'>tests8</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#8 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>40824</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler8</span> <span class='hs-varid'>number</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="epilogue">Epilogue</h2><p>There are over three hundred and fifty problems current on Project Euler, and I have as yet tackled but a small sample of them. In time, I hope this corpus will become fuller.</p><p>As a final and closing convenience, a main function is provided to run all the given test cases.</p><pre><span class='hs-definition'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runTestTT</span> <span class='hs-varop'>$</span> <span class='hs-conid'>TestList</span> <span class='hs-layout'>(</span> <span class='hs-varid'>tests1</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests2</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests3</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests4</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests5</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests6</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests7</span>
                           <span class='hs-varop'>++</span> <span class='hs-varid'>tests8</span>
                            <span class='hs-layout'>)</span>
</pre>

</body>
</html>
