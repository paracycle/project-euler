<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Project Euler</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="euler.css" type="text/css" />
</head>
<body>
<h1 id="project-euler">Project Euler</h1><blockquote><p>Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems. — <a href="http://projecteuler.net">Project Euler</a></p></blockquote><p>Follows is my attempt at the problems. I use Haskell and mathematics, two subjects in which I am a novice. In writing about my solutions and discoveries, I hope to present a gentle introduction to both.</p><p>I do presume a basic understanding of Haskell syntax, but not in any of the algorithmic techniques. Each solution should be comprehensible without former exposure to the problem. If you are unfamiliar with Haskell, you may still be able to follow along as many of the solutions are quite expressive — hopefully this will pique your interest in the language!</p><h2 id="building">Building</h2><p>This document is written in Literate Haskell, meaning it is executable as-is with <code>ghc</code> with the addition of two external packages. The easiest way to obtain them is via <code>cabal</code>. Their use is described later when they are imported.</p><pre><code>cabal install split data-memocombinators
</code></pre><p>It is prudent to enable compiler optimizations since some problems require a lot of processing, though it does not currently speed them up considerably.</p><pre><code>wget http://xaviershay.github.com/project-euler/euler.lhs
ghc --make -O2 euler.lhs
./euler
</code></pre><p>Alternatively, the <a href="https://github.com/xaviershay/project-euler">source repository</a> can be used. This allows running of individual problems, and the creation of this formatted HTML.</p><pre><code>git clone git@github.com:xaviershay/project-euler.git
cd project-euler

bin/run 1   # Run only problem 1
./build.sh  # Build full `.lhs` and `.html` files
</code></pre><h2 id="preamble">Preamble</h2><p>All imports are required to be at the top of the source file, so they are presented here and not duplicated in the problems for which they are specifically required.</p><p>Both sample input and expected answers (after they have been solved) will be expressed as HUnit tests below each solution.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Test</span><span class='hs-varop'>.</span><span class='hs-conid'>HUnit</span>
</pre>
<p>Importing the suite of <code>List</code> functions is non-controversial in a language that specifically excels at list processing.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>List</span>
<span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
</pre>
<p>In addition to the standard list packages, a common external package is used for basic string handling, primarly for parsing problem input.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span><span class='hs-varop'>.</span><span class='hs-conid'>Split</span>
</pre>
<p>In certain cases, the run-time characteristics of a list are not performant enough to provide a timely solution. In theses cases where constant-time random access is required, an array will be used instead.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Array</span>
</pre>
<p>Simalarly, the standard generic math functions are not fast enough for some tight inner loops. <code>Bits</code> gives access to bit shifting functions, useful in particular for fast divide by two using <code>shiftR</code>.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Bits</span>
</pre>
<p>The <code>Char</code> module is included for conversion functions handy for dealing with different input and output formats of the problems, specifically <code>digitToInt</code> to convert strings to integers.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Char</span>
</pre>
<p>Many solutions make heavy use of recursion, but Haskell leaves memoization as an option to the programmer, optimizing for smaller memory use rather than running time. As such, a package is used to provide easy memoization of arbitrary functions.</p><pre><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>MemoCombinators</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Memo</span>
</pre>
<p>Date functions are included for problem 19.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Time</span><span class='hs-varop'>.</span><span class='hs-conid'>Calendar</span>
<span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Time</span><span class='hs-varop'>.</span><span class='hs-conid'>Calendar</span><span class='hs-varop'>.</span><span class='hs-conid'>OrdinalDate</span>
</pre>
<p>Searching data structures is much easier using functions from <code>Maybe</code> such as <code>fromJust</code>.</p><pre><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span>
</pre>
<p>A helper function similar to <code>digitToInt</code> for use in parsing input. This is extracted to a function primarily so a type signature can be applied to <code>read</code>, so it knows what type to convert to.</p><pre><span class='hs-definition'>stringToInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>stringToInt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>read</span>
</pre>
<p>With those out of the way, on to the problems!</p><h2 id="problem-1">Problem 1</h2><blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote><p>Haskell allows an expressive solution to this problem. Removing the sum of the duplicate multiples afterwards is more efficient than trying to remove them before summing, as no comparisons or branches are required.</p><pre><span class='hs-definition'>euler1</span> <span class='hs-varid'>max</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sumMultiples</span> <span class='hs-num'>3</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sumMultiples</span> <span class='hs-num'>5</span> <span class='hs-comment'>-</span> <span class='hs-varid'>sumMultiples</span> <span class='hs-layout'>(</span><span class='hs-num'>3</span><span class='hs-varop'>*</span><span class='hs-num'>5</span><span class='hs-layout'>)</span>
 <span class='hs-keyword'>where</span>
   <span class='hs-varid'>sumMultiples</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-varop'>*</span><span class='hs-num'>2</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>max</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests1</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#1 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>23</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler1</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#1 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>233168</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler1</span> <span class='hs-num'>1000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-2">Problem 2</h2><blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p></blockquote><p>Start by defining an infinite sequence to generate Fibonacci values, made possible in Haskell by lazy evaluation. In many languages, this definition would never terminate.</p><pre><span class='hs-definition'>fibonacci</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seq</span> <span class='hs-num'>0</span> <span class='hs-num'>1</span> <span class='hs-keyword'>where</span> <span class='hs-varid'>seq</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span><span class='hs-varop'>+</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>seq</span> <span class='hs-varid'>y</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-varop'>+</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span>
</pre>
<p>Only as many values as are required will be generated.</p><pre><span class='hs-definition'>euler2</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>even</span> <span class='hs-varop'>.</span> <span class='hs-varid'>takeWhile</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;=</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fibonacci</span>
</pre>


<pre><span class='hs-definition'>tests2</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#2 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>44</span>      <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler2</span> <span class='hs-num'>40</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#2 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>4613732</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler2</span> <span class='hs-num'>4000000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-3">Problem 3</h2><blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143?</p></blockquote><p>Starting from two and working up, dividing the target by found factors on the way, any found factors will necessarily be prime: 4 will not be found because 2 would have already been found twice.</p><p><code>candidates</code> is extracted as an argument so that the algorithm can be reused in a more optimal way for future problems.</p><pre><span class='hs-definition'>primeFactorsFromCandidates</span> <span class='hs-varid'>candidates</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n</span> <span class='hs-varid'>candidates</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>candidates</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n'</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>n'</span> <span class='hs-varid'>p</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>n'</span> <span class='hs-varop'>`div`</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varid'>candidates</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactors'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n'</span> <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-num'>1</span> <span class='hs-varid'>candidates</span><span class='hs-layout'>)</span>
      <span class='hs-keyword'>where</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-varid'>candidates</span>
</pre>


<pre><span class='hs-definition'>naivePrimeFactors</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactorsFromCandidates</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>2</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
</pre>
<p>The solution is then the last factor found. Note that no explicit logic for “primeness” is required.</p><pre><span class='hs-definition'>euler3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>last</span> <span class='hs-varop'>.</span> <span class='hs-varid'>naivePrimeFactors</span>
</pre>


<pre><span class='hs-definition'>tests3</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#3 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>29</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler3</span> <span class='hs-num'>13195</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#3 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>6857</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler3</span> <span class='hs-num'>600851475143</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-4">Problem 4</h2><blockquote><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is<br />91 × 99 = 9009.</p><p>Find the largest palindrome made from the product of two 3-digit numbers.</p></blockquote><p>The easiest palindrome check is a string comparison between the number and its reversed form.</p><pre><span class='hs-definition'>palindrome</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>x'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>x'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>x'</span>
</pre>
<p>Since the input set is relatively small, it would suffice to generate a list of all possible numbers and filter them. The search space can be reduced dramatically, however, with two techniques.</p><p>It is known that the answer will be six digits long (maximum length of two 3-digit numbers multiplied), and will be of the form:</p><blockquote><p>= 100000<i>a</i> + 10000<i>b</i> + 1000<i>c</i> + 100<i>c</i> + 10<i>b</i> + <i>a</i><br /> = 100001<i>a</i> + 10010<i>b</i> + 1100<i>c</i><br /> = 11(9091<i>a</i> + 910<i>b</i> + 110<i>c</i>)<br /></p></blockquote><p>This informs us that the answer must be divisible by 11, which allows the input set to be trimmed considerably, yielding an order of magnitude speed up.</p><p>Intuitively, the answer will be the product of two digits greater than nine hundred, which allows us to scope the search space even further. While this may be presumptuous, if no solution is found it is easy enough to drop the lower bound.</p><pre><span class='hs-definition'>euler4</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varid'>palindromes</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>palindromes</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>z</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>*</span> <span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-varid'>palindrome</span> <span class='hs-varid'>z</span><span class='hs-keyglyph'>]</span>
    <span class='hs-varid'>ys</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>y</span> <span class='hs-num'>11</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests4</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#4 test"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>9009</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler4</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>90</span><span class='hs-keyglyph'>..</span><span class='hs-num'>99</span><span class='hs-keyglyph'>]</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#4 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>906609</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler4</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>900</span><span class='hs-keyglyph'>..</span><span class='hs-num'>999</span><span class='hs-keyglyph'>]</span>
  <span class='hs-keyglyph'>]</span>
</pre>

<h2 id="problem-5">Problem 5</h2><blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p></blockquote><p>Using the built-in <code>lcm</code> function is arguably cheating, but the prime-factoring basis of the algorithm has already be written in problem three.</p><pre><span class='hs-definition'>euler5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl1</span> <span class='hs-varid'>lcm</span> <span class='hs-varop'>.</span> <span class='hs-varid'>enumFromTo</span> <span class='hs-num'>1</span>
</pre>


<pre><span class='hs-definition'>tests5</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#5 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>2520</span>      <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler5</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#5 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>232792560</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler5</span> <span class='hs-num'>20</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-6">Problem 6</h2><blockquote><p>The sum of the squares of the first ten natural numbers is:</p><p>1<sup>2</sup> + 2<sup>2</sup> + … + 10<sup>2</sup> = 385</p><p>The square of the sum of the first ten natural numbers is:</p><p>(1 + 2 + … + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</p><p>The difference between the two is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote><p>The problem translates naturally into code.</p><pre><span class='hs-definition'>euler6</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-varop'>^</span><span class='hs-num'>2</span> <span class='hs-comment'>-</span> <span class='hs-layout'>(</span><span class='hs-varid'>sum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varop'>^</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests6</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#6 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>2640</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler6</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#6 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>25164150</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler6</span> <span class='hs-num'>100</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<p>There is alternative algebraic solution that relies on knowing that the sum of the first <i>n</i> natural numbers is <i>n</i>(<i>n</i>+1)/2 and that the sum of the first <i>n</i> squares is <i>n</i>(<i>n</i>+1)(2<i>n</i>+1)/6. Squaring both and taking the difference with <i>n</i> = 100 yields the correct answer.</p><h2 id="problem-7">Problem 7</h2><blockquote><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6<sup>th</sup> prime is 13.</p><p>What is the 10,001<sup>st</sup> prime number?</p></blockquote><p>Having already read the <a href="http://www.haskell.org/haskellwiki/Prime_numbers">Haskell wiki page on prime generation</a> a few times, I cheated and nabbed an algorithm with a good trade-off between readability and efficiency (“Optimal trial divison”).</p><p>It works by dividing each new candidate number by every prime generated so far that is less than the square root of the number. If none divide evenly into the number, then the number is prime. Non-prime divisors do not need to be checked since they themselves would have had a prime factor which has already been tested.</p><pre><span class='hs-definition'>coprime</span> <span class='hs-varid'>factors</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>p</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-varop'>*</span><span class='hs-varid'>p</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>rem</span> <span class='hs-varid'>n</span> <span class='hs-varid'>p</span> <span class='hs-varop'>/=</span> <span class='hs-num'>0</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span> <span class='hs-varid'>factors</span>
</pre>


<pre><span class='hs-definition'>primes</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-conop'>:</span> <span class='hs-num'>3</span> <span class='hs-conop'>:</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>coprime</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tail</span> <span class='hs-varid'>primes</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>5</span><span class='hs-layout'>,</span><span class='hs-num'>7</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>euler7</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-varop'>$</span> <span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>primes</span>
</pre>


<pre><span class='hs-definition'>tests7</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#7 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>13</span>     <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler7</span> <span class='hs-num'>6</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#7 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>104743</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler7</span> <span class='hs-num'>10001</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-8">Problem 8</h2><blockquote><p>Find the greatest product of five consecutive digits in the 1000-digit number given below.</p></blockquote><pre><span class='hs-definition'>number</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-str'>"73167176531330624919225119674426574742355349194934"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"96983520312774506326239578318016984801869478851843"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"85861560789112949495459501737958331952853208805511"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"12540698747158523863050715693290963295227443043557"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"66896648950445244523161731856403098711121722383113"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"62229893423380308135336276614282806444486645238749"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"30358907296290491560440772390713810515859307960866"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"70172427121883998797908792274921901699720888093776"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"65727333001053367881220235421809751254540594752243"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"52584907711670556013604839586446706324415722155397"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"53697817977846174064955149290862569321978468622482"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"83972241375657056057490261407972968652414535100474"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"82166370484403199890008895243450658541227588666881"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"16427171479924442928230863465674813919123162824586"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"17866458359124566529476545682848912883142607690042"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"24219022671055626321111109370544217506941658960408"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"07198403850962455444362981230987879927244284909188"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"84580156166097919133875499200524063689912560717606"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"05886116467109405077541002256983155200055935729725"</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"71636269561882670428252483600823257530420752963450"</span>
</pre>
<p>My first solution used a cumbersome arrangement of <code>splitAt</code> calls to compute a list of all consecutive numbers. I was then made aware of the <code>tails</code> function, which when combined with <code>take 5</code> does essentially the same thing. It does return sequences of less than five digits (from the end of the string), but these do not need to be filtered since their product will never be more than the same string with an extra preceeding digit.</p><pre><span class='hs-definition'>euler8</span> <span class='hs-varid'>input</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>product</span> <span class='hs-varop'>.</span> <span class='hs-varid'>take</span> <span class='hs-num'>5</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tails</span> <span class='hs-varid'>digits</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>digits</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>digitToInt</span> <span class='hs-varid'>input</span>
</pre>


<pre><span class='hs-definition'>tests8</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#8 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>40824</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler8</span> <span class='hs-varid'>number</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-9">Problem 9</h2><blockquote><p>A Pythagorean triplet is a set of three natural numbers, <i>a</i> &lt; <i>b</i> &lt; <i>c</i>, for which <i>a</i><sup>2</sup> + <i>b</i><sup>2</sup> = <i>c</i><sup>2</sup>.</p><p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.</p><p>There exists exactly one Pythagorean triplet for which <i>a</i> + <i>b</i> + <i>c</i> = 1000. Find the product <i>abc</i>.</p></blockquote><p>Using a brute force method, the inner loop is over values of <em>b</em>. It therefore makes sense to optimize that loop by bounding its range as much as possible. The lower bound is obvious since <i>a</i> &lt; <i>b</i>. A naive upper bound is 1000 - <i>a</i> - <i>a</i>, since <i>b</i> &gt; <i>a</i>, <i>c</i> &gt; <i>a</i>, and the sum of all three must equal 1000. However, considering also that <i>c</i> &gt; <i>b</i> allows us to further eliminate the top half of the range.</p><pre><span class='hs-definition'>maxB</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>`div`</span> <span class='hs-num'>2</span>
</pre>


<pre><span class='hs-definition'>euler9</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-varop'>*</span><span class='hs-varid'>b</span><span class='hs-varop'>*</span><span class='hs-varid'>c</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>
                         <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>maxB</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>
                         <span class='hs-keyword'>let</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-comment'>-</span> <span class='hs-varid'>b</span> <span class='hs-comment'>-</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span>
                         <span class='hs-varid'>a</span> <span class='hs-varop'>*</span> <span class='hs-varid'>a</span> <span class='hs-varop'>+</span> <span class='hs-varid'>b</span> <span class='hs-varop'>*</span> <span class='hs-varid'>b</span> <span class='hs-varop'>==</span> <span class='hs-varid'>c</span> <span class='hs-varop'>*</span> <span class='hs-varid'>c</span>
                <span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests9</span> <span class='hs-keyglyph'>=</span>
 <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#9 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>60</span>       <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler9</span> <span class='hs-num'>12</span>
 <span class='hs-layout'>,</span> <span class='hs-str'>"#9 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>31875000</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler9</span> <span class='hs-num'>1000</span>
 <span class='hs-keyglyph'>]</span>
</pre>
<p>For a brute force method that naturally maps to the problem description this solution is not bad. Substitution and rearranging of the equations can lead to better lower and upper bounds for the search space, but this is merely a refinement of the same algorithm. There is a more elegant algorithmic approach.</p><p><a href="http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple">Euclid’s formula</a> states that for all Pythagorean triples the following hold true where <em>m</em> and <em>n</em> are positive integers:</p><blockquote><p><i>a</i> = <i>m</i><sup>2</sup> - <i>n</i><sup>2</sup><br /> <i>b</i> = 2<i>mn</i><br /> <i>c</i> = <i>m</i><sup>2</sup> + <i>n</i><sup>2</sup><br /></p></blockquote><p>This allows the problem equation to be simplified radically.</p><blockquote><p>(<i>m</i><sup>2</sup> - <i>n</i><sup>2</sup>) + 2<i>mn</i> + (<i>m</i><sup>2</sup> + <i>n</i><sup>2</sup>) = 1000<br /> <i>m</i><sup>2</sup> + <i>mn</i> = 500<br /> <i>m</i>(<i>m</i> + <i>n</i>) = 500<br /></p></blockquote><p>A solution can then be found by finding two matching candidates from the factors of 500, in this case <i>m</i> = 20, <i>n</i> = 5.</p><h2 id="problem-10">Problem 10</h2><blockquote><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p><p>Find the sum of all the primes below two million.</p></blockquote><p>Re-uses the <code>primes</code> function defined in problem seven. Takes a few seconds, but gets the solution in the end.</p><pre><span class='hs-definition'>euler10</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>takeWhile</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>primes</span>
</pre>


<pre><span class='hs-definition'>tests10</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#10 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>17</span>           <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler10</span> <span class='hs-num'>10</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#10 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>142913828922</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler10</span> <span class='hs-num'>2000000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-11">Problem 11</h2><blockquote><p>In the 20 × 20 grid below, what is the greatest product of four adjacent numbers in a straight line in any direction (up, down, left, right, or diagonally)?</p></blockquote><pre><span class='hs-definition'>grid11</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-str'>"08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48 "</span>
</pre>
<p>There is no shortcut method to calculating the greatest product for this problem, so a search is in order. The difficulty is in enumerating all of the candidates. If you are not familiar with <a href="http://www.haskell.org/haskellwiki/Pointfree">pointfree style</a>, this solution is going to be a baptism of fire!</p><p>The solution can easily be expressed as high level concepts, with the details to be filled in below.</p><pre><span class='hs-definition'>euler11</span> <span class='hs-varid'>w</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>product</span> <span class='hs-varop'>.</span> <span class='hs-varid'>candidates</span>
 <span class='hs-keyword'>where</span>
   <span class='hs-varid'>candidates</span> <span class='hs-varid'>input</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-layout'>(</span><span class='hs-varid'>parse</span> <span class='hs-varid'>input</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>directions</span>
</pre>
<p>The algorithm provides separate methods to enumerate candidates for each of the four directions. The other four directions are equivalent and do not need to be considered.</p><pre>   <span class='hs-varid'>directions</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>east</span><span class='hs-layout'>,</span> <span class='hs-varid'>southEast</span><span class='hs-layout'>,</span> <span class='hs-varid'>south</span><span class='hs-layout'>,</span> <span class='hs-varid'>southWest</span><span class='hs-keyglyph'>]</span>
</pre>
<p><code>adjacent</code> will calculate all possible sublists of the grid that can be formed by starting at each cell and walking <code>l</code> cells in the given direction.</p><pre>   <span class='hs-varid'>adjacent</span> <span class='hs-varid'>grid</span> <span class='hs-varid'>direction</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-varop'>.</span> <span class='hs-varid'>direction</span> <span class='hs-varop'>$</span> <span class='hs-varid'>grid</span>
</pre>
<p>East is the simplest direction. For each row in the grid, generate the tails and take the first four of each. As in problem eight, candidates less than the required length do not need to be filtered since they cannot possibly provide an incorrect answer, and add only a neglible amount to the running time.</p><pre>   <span class='hs-varid'>east</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tails</span><span class='hs-layout'>)</span>
</pre>
<p>South is exactly the same logic as east, except with rows and columns switched.</p><pre>   <span class='hs-varid'>south</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>east</span> <span class='hs-varop'>.</span> <span class='hs-varid'>transpose</span>
</pre>
<p>A cute functional trick is used to extract the diagonals from a grid. <code>zipWith</code> shears off the south-west half of the grid, leaving the columns of the resulting half-grid representing the diagonals. <code>transpose</code> makes them into the rows.</p><pre>   <span class='hs-varid'>diagonals</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>transpose</span> <span class='hs-varop'>.</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>drop</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
</pre>
<p>This is not sufficient however. Diagonals from the excluded south-west half still need to be included as candidates! Further, only the first four of each diagonal is currently being included. To compensate, a series of sub-grids is created each with the top row of the last grid dropped, and diagonals are generated for each of them. Note that <code>tails</code> here is being applied to the grid itself, not the rows of the grid as it was above.</p><pre>   <span class='hs-varid'>southEast</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>diagonals</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tails</span>
</pre>
<p>South-west has a similar relationship to south-east as south does to east.</p><pre>   <span class='hs-varid'>southWest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>southEast</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>reverse</span>
</pre>
<p>Parsing is the least interesting part of the solution, so has been relegated to the bottom of the definition.</p><pre>   <span class='hs-varid'>parse</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>chunk</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>stringToInt</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>chunk</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>tests11</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#11 test"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>70600674</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler11</span> <span class='hs-num'>20</span> <span class='hs-num'>4</span> <span class='hs-varid'>grid11</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-12">Problem 12</h2><blockquote><p>The sequence of triangle numbers is generated by adding the natural numbers. So the seventh triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:</p><p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>The factors of the seventh triangle number 28 are:</p><p>1, 2, 4, 7, 14, 28</p><p>This is the first triangle number to have over five divisors. What is the value of the first triangle number to have over five hundred divisors?</p></blockquote><p>An infinite sequence of triangle numbers is a delight to define in Haskell. This is an alternative approach than that used for the Fibonacci sequence in problem two, though they are mostly interchangeable.</p><pre><span class='hs-definition'>triangles</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span><span class='hs-conop'>:</span><span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varid'>triangles</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>2</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
</pre>
<p>The prime factorization algorithm from problem three is reused here, though rather than naively testing all numbers it uses the <code>primes</code> generator from problem seven to reduce the number of tests required.</p><pre><span class='hs-definition'>primeFactors</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primeFactorsFromCandidates</span> <span class='hs-varid'>primes</span>
</pre>
<p>The number of divisors a number has can be calculated by multiplying the powers of each prime factor plus one. For example, the prime factors of 28 are 2<sup>2</sup> + 7<sup>1</sup> therefore the number of divisors is (2+1) × (1+1) = 6.</p><pre><span class='hs-definition'>numFactors</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl1</span> <span class='hs-layout'>(</span><span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>length</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>group</span> <span class='hs-varop'>.</span> <span class='hs-varid'>primeFactors</span>
</pre>
<p>A reasonable lower bound such as 500 × 500 could be specified for the triangle numbers, but it makes a negligible difference to the running time of the search. The number 1 is excluded since it has no prime factors.</p><pre><span class='hs-definition'>euler12</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>drop</span> <span class='hs-num'>1</span> <span class='hs-varid'>triangles</span><span class='hs-layout'>,</span> <span class='hs-varid'>numFactors</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests12</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#12 given"</span>    <span class='hs-varop'>~:</span> <span class='hs-num'>28</span>       <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler12</span> <span class='hs-num'>5</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#12 problems"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>76576500</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler12</span> <span class='hs-num'>500</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-13">Problem 13</h2><blockquote><p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.</p></blockquote><pre><span class='hs-definition'>numbers13</span> <span class='hs-keyglyph'>=</span>
 <span class='hs-keyglyph'>[</span><span class='hs-num'>37107287533902102798797998220837590246510135740250</span>
 <span class='hs-layout'>,</span><span class='hs-num'>46376937677490009712648124896970078050417018260538</span>
 <span class='hs-layout'>,</span><span class='hs-num'>74324986199524741059474233309513058123726617309629</span>
 <span class='hs-layout'>,</span><span class='hs-num'>91942213363574161572522430563301811072406154908250</span>
 <span class='hs-layout'>,</span><span class='hs-num'>23067588207539346171171980310421047513778063246676</span>
 <span class='hs-layout'>,</span><span class='hs-num'>89261670696623633820136378418383684178734361726757</span>
 <span class='hs-layout'>,</span><span class='hs-num'>28112879812849979408065481931592621691275889832738</span>
 <span class='hs-layout'>,</span><span class='hs-num'>44274228917432520321923589422876796487670272189318</span>
 <span class='hs-layout'>,</span><span class='hs-num'>47451445736001306439091167216856844588711603153276</span>
 <span class='hs-layout'>,</span><span class='hs-num'>70386486105843025439939619828917593665686757934951</span>
 <span class='hs-layout'>,</span><span class='hs-num'>62176457141856560629502157223196586755079324193331</span>
 <span class='hs-layout'>,</span><span class='hs-num'>64906352462741904929101432445813822663347944758178</span>
 <span class='hs-layout'>,</span><span class='hs-num'>92575867718337217661963751590579239728245598838407</span>
 <span class='hs-layout'>,</span><span class='hs-num'>58203565325359399008402633568948830189458628227828</span>
 <span class='hs-layout'>,</span><span class='hs-num'>80181199384826282014278194139940567587151170094390</span>
 <span class='hs-layout'>,</span><span class='hs-num'>35398664372827112653829987240784473053190104293586</span>
 <span class='hs-layout'>,</span><span class='hs-num'>86515506006295864861532075273371959191420517255829</span>
 <span class='hs-layout'>,</span><span class='hs-num'>71693888707715466499115593487603532921714970056938</span>
 <span class='hs-layout'>,</span><span class='hs-num'>54370070576826684624621495650076471787294438377604</span>
 <span class='hs-layout'>,</span><span class='hs-num'>53282654108756828443191190634694037855217779295145</span>
 <span class='hs-layout'>,</span><span class='hs-num'>36123272525000296071075082563815656710885258350721</span>
 <span class='hs-layout'>,</span><span class='hs-num'>45876576172410976447339110607218265236877223636045</span>
 <span class='hs-layout'>,</span><span class='hs-num'>17423706905851860660448207621209813287860733969412</span>
 <span class='hs-layout'>,</span><span class='hs-num'>81142660418086830619328460811191061556940512689692</span>
 <span class='hs-layout'>,</span><span class='hs-num'>51934325451728388641918047049293215058642563049483</span>
 <span class='hs-layout'>,</span><span class='hs-num'>62467221648435076201727918039944693004732956340691</span>
 <span class='hs-layout'>,</span><span class='hs-num'>15732444386908125794514089057706229429197107928209</span>
 <span class='hs-layout'>,</span><span class='hs-num'>55037687525678773091862540744969844508330393682126</span>
 <span class='hs-layout'>,</span><span class='hs-num'>18336384825330154686196124348767681297534375946515</span>
 <span class='hs-layout'>,</span><span class='hs-num'>80386287592878490201521685554828717201219257766954</span>
 <span class='hs-layout'>,</span><span class='hs-num'>78182833757993103614740356856449095527097864797581</span>
 <span class='hs-layout'>,</span><span class='hs-num'>16726320100436897842553539920931837441497806860984</span>
 <span class='hs-layout'>,</span><span class='hs-num'>48403098129077791799088218795327364475675590848030</span>
 <span class='hs-layout'>,</span><span class='hs-num'>87086987551392711854517078544161852424320693150332</span>
 <span class='hs-layout'>,</span><span class='hs-num'>59959406895756536782107074926966537676326235447210</span>
 <span class='hs-layout'>,</span><span class='hs-num'>69793950679652694742597709739166693763042633987085</span>
 <span class='hs-layout'>,</span><span class='hs-num'>41052684708299085211399427365734116182760315001271</span>
 <span class='hs-layout'>,</span><span class='hs-num'>65378607361501080857009149939512557028198746004375</span>
 <span class='hs-layout'>,</span><span class='hs-num'>35829035317434717326932123578154982629742552737307</span>
 <span class='hs-layout'>,</span><span class='hs-num'>94953759765105305946966067683156574377167401875275</span>
 <span class='hs-layout'>,</span><span class='hs-num'>88902802571733229619176668713819931811048770190271</span>
 <span class='hs-layout'>,</span><span class='hs-num'>25267680276078003013678680992525463401061632866526</span>
 <span class='hs-layout'>,</span><span class='hs-num'>36270218540497705585629946580636237993140746255962</span>
 <span class='hs-layout'>,</span><span class='hs-num'>24074486908231174977792365466257246923322810917141</span>
 <span class='hs-layout'>,</span><span class='hs-num'>91430288197103288597806669760892938638285025333403</span>
 <span class='hs-layout'>,</span><span class='hs-num'>34413065578016127815921815005561868836468420090470</span>
 <span class='hs-layout'>,</span><span class='hs-num'>23053081172816430487623791969842487255036638784583</span>
 <span class='hs-layout'>,</span><span class='hs-num'>11487696932154902810424020138335124462181441773470</span>
 <span class='hs-layout'>,</span><span class='hs-num'>63783299490636259666498587618221225225512486764533</span>
 <span class='hs-layout'>,</span><span class='hs-num'>67720186971698544312419572409913959008952310058822</span>
 <span class='hs-layout'>,</span><span class='hs-num'>95548255300263520781532296796249481641953868218774</span>
 <span class='hs-layout'>,</span><span class='hs-num'>76085327132285723110424803456124867697064507995236</span>
 <span class='hs-layout'>,</span><span class='hs-num'>37774242535411291684276865538926205024910326572967</span>
 <span class='hs-layout'>,</span><span class='hs-num'>23701913275725675285653248258265463092207058596522</span>
 <span class='hs-layout'>,</span><span class='hs-num'>29798860272258331913126375147341994889534765745501</span>
 <span class='hs-layout'>,</span><span class='hs-num'>18495701454879288984856827726077713721403798879715</span>
 <span class='hs-layout'>,</span><span class='hs-num'>38298203783031473527721580348144513491373226651381</span>
 <span class='hs-layout'>,</span><span class='hs-num'>34829543829199918180278916522431027392251122869539</span>
 <span class='hs-layout'>,</span><span class='hs-num'>40957953066405232632538044100059654939159879593635</span>
 <span class='hs-layout'>,</span><span class='hs-num'>29746152185502371307642255121183693803580388584903</span>
 <span class='hs-layout'>,</span><span class='hs-num'>41698116222072977186158236678424689157993532961922</span>
 <span class='hs-layout'>,</span><span class='hs-num'>62467957194401269043877107275048102390895523597457</span>
 <span class='hs-layout'>,</span><span class='hs-num'>23189706772547915061505504953922979530901129967519</span>
 <span class='hs-layout'>,</span><span class='hs-num'>86188088225875314529584099251203829009407770775672</span>
 <span class='hs-layout'>,</span><span class='hs-num'>11306739708304724483816533873502340845647058077308</span>
 <span class='hs-layout'>,</span><span class='hs-num'>82959174767140363198008187129011875491310547126581</span>
 <span class='hs-layout'>,</span><span class='hs-num'>97623331044818386269515456334926366572897563400500</span>
 <span class='hs-layout'>,</span><span class='hs-num'>42846280183517070527831839425882145521227251250327</span>
 <span class='hs-layout'>,</span><span class='hs-num'>55121603546981200581762165212827652751691296897789</span>
 <span class='hs-layout'>,</span><span class='hs-num'>32238195734329339946437501907836945765883352399886</span>
 <span class='hs-layout'>,</span><span class='hs-num'>75506164965184775180738168837861091527357929701337</span>
 <span class='hs-layout'>,</span><span class='hs-num'>62177842752192623401942399639168044983993173312731</span>
 <span class='hs-layout'>,</span><span class='hs-num'>32924185707147349566916674687634660915035914677504</span>
 <span class='hs-layout'>,</span><span class='hs-num'>99518671430235219628894890102423325116913619626622</span>
 <span class='hs-layout'>,</span><span class='hs-num'>73267460800591547471830798392868535206946944540724</span>
 <span class='hs-layout'>,</span><span class='hs-num'>76841822524674417161514036427982273348055556214818</span>
 <span class='hs-layout'>,</span><span class='hs-num'>97142617910342598647204516893989422179826088076852</span>
 <span class='hs-layout'>,</span><span class='hs-num'>87783646182799346313767754307809363333018982642090</span>
 <span class='hs-layout'>,</span><span class='hs-num'>10848802521674670883215120185883543223812876952786</span>
 <span class='hs-layout'>,</span><span class='hs-num'>71329612474782464538636993009049310363619763878039</span>
 <span class='hs-layout'>,</span><span class='hs-num'>62184073572399794223406235393808339651327408011116</span>
 <span class='hs-layout'>,</span><span class='hs-num'>66627891981488087797941876876144230030984490851411</span>
 <span class='hs-layout'>,</span><span class='hs-num'>60661826293682836764744779239180335110989069790714</span>
 <span class='hs-layout'>,</span><span class='hs-num'>85786944089552990653640447425576083659976645795096</span>
 <span class='hs-layout'>,</span><span class='hs-num'>66024396409905389607120198219976047599490197230297</span>
 <span class='hs-layout'>,</span><span class='hs-num'>64913982680032973156037120041377903785566085089252</span>
 <span class='hs-layout'>,</span><span class='hs-num'>16730939319872750275468906903707539413042652315011</span>
 <span class='hs-layout'>,</span><span class='hs-num'>94809377245048795150954100921645863754710598436791</span>
 <span class='hs-layout'>,</span><span class='hs-num'>78639167021187492431995700641917969777599028300699</span>
 <span class='hs-layout'>,</span><span class='hs-num'>15368713711936614952811305876380278410754449733078</span>
 <span class='hs-layout'>,</span><span class='hs-num'>40789923115535562561142322423255033685442488917353</span>
 <span class='hs-layout'>,</span><span class='hs-num'>44889911501440648020369068063960672322193204149535</span>
 <span class='hs-layout'>,</span><span class='hs-num'>41503128880339536053299340368006977710650566631954</span>
 <span class='hs-layout'>,</span><span class='hs-num'>81234880673210146739058568557934581403627822703280</span>
 <span class='hs-layout'>,</span><span class='hs-num'>82616570773948327592232845941706525094512325230608</span>
 <span class='hs-layout'>,</span><span class='hs-num'>22918802058777319719839450180888072429661980811197</span>
 <span class='hs-layout'>,</span><span class='hs-num'>77158542502016545090413245809786882778948721859617</span>
 <span class='hs-layout'>,</span><span class='hs-num'>72107838435069186155435662884062257473692284509516</span>
 <span class='hs-layout'>,</span><span class='hs-num'>20849603980134001723930671666823555245252804609722</span>
 <span class='hs-layout'>,</span><span class='hs-num'>53503534226472524250874054075591789781264330331690</span>
 <span class='hs-keyglyph'>]</span>
</pre>
<p>There really is no trick to this. It is tempting to try summing only the first 11 digits of each number, and while that does work for this particular input it is not a general solution, since additions from the remaining 39 digits can cause carry overs that affect the result.</p><pre><span class='hs-definition'>euler13</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-num'>10</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>show</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sum</span>
</pre>


<pre><span class='hs-definition'>tests13</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#13 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-str'>"5537376230"</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler13</span> <span class='hs-varid'>numbers13</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-14">Problem 14</h2><blockquote><p>The following iterative sequence is defined for the set of positive integers:</p><p><i>n</i> -&gt; <i>n</i>/2 (<i>n</i> <i>is</i> <i>even</i>)<br /> <i>n</i> -&gt; 3<i>n</i> + 1 (<i>n</i> <i>is</i> <i>odd</i>)</p><p>Using the rule above and starting with 13, we generate the following sequence:</p><p>13, 40, 20, 10, 5, 16, 8, 4, 2, 1</p><p>It can be seen that this sequence contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.</p><p>Which starting number, under one million, produces the longest chain?</p><p>Note that once the chain starts the terms are allowed to go above one million.</p></blockquote><p>A recursive function can be used to calculate the length of the collatz sequence for a number. Memoization is critical here as it speeds up the solution by an order of magnitude.</p><pre><span class='hs-definition'>collatz</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span>
<span class='hs-definition'>collatz</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Memo</span><span class='hs-varop'>.</span><span class='hs-varid'>arrayRange</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span><span class='hs-layout'>,</span><span class='hs-num'>1000000</span><span class='hs-layout'>)</span> <span class='hs-varid'>collatz'</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>collatz'</span> <span class='hs-num'>1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
    <span class='hs-varid'>collatz'</span> <span class='hs-varid'>x</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>even</span> <span class='hs-varid'>x</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>collatz</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`shiftR`</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>collatz</span> <span class='hs-layout'>(</span><span class='hs-num'>3</span> <span class='hs-varop'>*</span> <span class='hs-varid'>x</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
</pre>
<p>Tuple comparison in Haskell is done using the first element, so <code>max (5,1) (4,100)</code> will return <code>(5,1)</code>. This is taken advantage to find the maximum index of a list by zipping the index of each element into the list (creating a list of tuples), finding the maximum tuple (which will compare on the original value), then returning the second element of that tuple.</p><p>The strict function <code>fold1' max</code> is used rather than <code>maximum</code> so that it executes with a constant memory bound. See the Haskell wiki page on <a href="http://www.haskell.org/haskellwiki/Stack_overflow">stack overflow</a> for more information.</p><pre><span class='hs-definition'>maxIndex</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldl1'</span> <span class='hs-varid'>max</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-varid'>zip</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
</pre>
<p>The solution is a trivial combination of these two functions.</p><pre><span class='hs-definition'>euler14</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>maxIndex</span> <span class='hs-varid'>lengths</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>lengths</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>collatz</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests14</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#14 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>9</span>      <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler14</span> <span class='hs-num'>13</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#14 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>837799</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler14</span> <span class='hs-num'>1000000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-15">Problem 15</h2><blockquote><p>Starting in the top left corner of a 2 × 2 grid, there are 6 routes (without backtracking) to the bottom right corner.</p><p>How many routes are there through a 20 × 20 grid?</p></blockquote><p>Let the number of paths through a grid of <i>x</i> × <i>y</i> be a function <i>p</i>(<i>x</i>, <i>y</i>). For any grid, there are only two immediate paths leading into the final corner. Therefore, <i>p</i>(<i>x</i>, <i>y</i>) will be equal to <i>p</i>(<i>x</i>–1, <i>y</i>) + <i>p</i>(<i>x</i>, <i>y</i>–1), terminating at 1 whenever <i>x</i> or <i>y</i> is 0. In the case of a 2 × 2 grid:</p><blockquote><p>= <i>p</i>(2, 2)<br /> = <i>p</i>(2, 1) + <i>p</i>(1, 2)<br /> = 2<i>p</i>(1, 1) + <i>p</i>(2, 0) + <i>p</i>(0, 2)<br /> = 2(<i>p</i>(0, 1) + <i>p</i>(1, 0)) + <i>p</i>(2, 0) + <i>p</i>(0, 2)<br /> = 2 × 2 + 1 + 1<br /> = 6<br /></p></blockquote><p>As with the last problem, memoization is essential to allow this algorithm a reasonable running time, though the extra speed up of an <code>arrayRange</code> is not required. This is beneficial since the maximum input does not need to be hard coded.</p><pre><span class='hs-definition'>gridPaths</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Memo</span><span class='hs-varop'>.</span><span class='hs-varid'>memo2</span> <span class='hs-conid'>Memo</span><span class='hs-varop'>.</span><span class='hs-varid'>integral</span> <span class='hs-conid'>Memo</span><span class='hs-varop'>.</span><span class='hs-varid'>integral</span> <span class='hs-varid'>f</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
    <span class='hs-varid'>f</span> <span class='hs-num'>0</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
    <span class='hs-varid'>f</span> <span class='hs-varid'>w</span> <span class='hs-varid'>h</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>gridPaths</span> <span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>h</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-varid'>gridPaths</span> <span class='hs-varid'>w</span> <span class='hs-layout'>(</span><span class='hs-varid'>h</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>euler15</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gridPaths</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n</span>
</pre>


<pre><span class='hs-definition'>tests15</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#15 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>6</span>            <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler15</span> <span class='hs-num'>2</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#15 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>137846528820</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler15</span> <span class='hs-num'>20</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<p>Another way of approaching the problem is to recognize that all routes must go twenty steps left and twenty steps down, yielding a collection of forty “moves”. The total number of arrangements of moves is then 40!. This contains duplicate paths however, since swapping two down moves results in the same path. The possible arrangements for the down moves is is 20!, same for left, so the total number of arrangements without duplicates is 40!/(20! × 20!).</p><p>This is a standard calculation in combinatorics known as a binomial coefficient, or “n choose k” where <i>n</i> = 40 and <i>k</i> = 20.</p><h2 id="problem-16">Problem 16</h2><blockquote><p>2<sup>15</sup> = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.</p><p>What is the sum of the digits of the number 2<sup>1000</sup>?</p></blockquote><p>Does what is says on the packet.</p><pre><span class='hs-definition'>sumOfDigits</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>digitToInt</span> <span class='hs-varop'>.</span> <span class='hs-varid'>show</span>
</pre>


<pre><span class='hs-definition'>euler16</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sumOfDigits</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varop'>^</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span>
</pre>


<pre><span class='hs-definition'>tests16</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#16 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>26</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler16</span> <span class='hs-num'>15</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#16 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>1366</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler16</span> <span class='hs-num'>1000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-17">Problem 17</h2><blockquote><p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.</p><p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p><p>Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of “and” when writing out numbers is in compliance with British usage.</p></blockquote><p>Some basic translations of numbers are required to bootstrap the algorithm.</p><pre><span class='hs-definition'>singles</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>words</span> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>words</span> <span class='hs-keyglyph'>=</span>
      <span class='hs-keyglyph'>[</span> <span class='hs-str'>"one"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"two"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"three"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"four"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"five"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"six"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"seven"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"eight"</span>
      <span class='hs-layout'>,</span> <span class='hs-str'>"nine"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"ten"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"eleven"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"twelve"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"thirteen"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"fourteen"</span>
      <span class='hs-layout'>,</span> <span class='hs-str'>"fifteen"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"sixteen"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"seventeen"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"eighteen"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"nineteen"</span> <span class='hs-keyglyph'>]</span>
<span class='hs-definition'>tens</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>words</span> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-comment'>-</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>words</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-str'>"twenty"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"thirty"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"forty"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"fifty"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"sixty"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"seventy"</span>
            <span class='hs-layout'>,</span> <span class='hs-str'>"eighty"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"ninety"</span> <span class='hs-layout'>,</span> <span class='hs-str'>"hundred"</span> <span class='hs-keyglyph'>]</span>
</pre>

<p>For numbers below 100, translating numbers to words is somewhat arbitary, but the logic is not too cumbersome.</p><pre><span class='hs-definition'>formatBelow100</span> <span class='hs-varid'>x</span>
  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;</span> <span class='hs-num'>20</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>singles</span> <span class='hs-varid'>x</span>
  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>x</span> <span class='hs-num'>10</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>formatTens</span> <span class='hs-varid'>x</span>
  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>formatTens</span> <span class='hs-varid'>x</span> <span class='hs-varop'>++</span> <span class='hs-str'>" "</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-varid'>singles</span> <span class='hs-varop'>$</span> <span class='hs-varid'>rem</span> <span class='hs-varid'>x</span> <span class='hs-num'>10</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>formatTens</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tens</span> <span class='hs-varop'>$</span> <span class='hs-varid'>div</span> <span class='hs-varid'>x</span> <span class='hs-num'>10</span>
</pre>
<p>For numbers greater than 100 the translation logic is much simpler and can be coded inline. This data structure is the core of the algorithm, and it is obvious how it could be extended to support millions, billions, and beyond.</p><pre><span class='hs-definition'>ranges</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>f</span> <span class='hs-varid'>label</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>numberToWords</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-str'>" "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>label</span> <span class='hs-keyword'>in</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>formatBelow100</span><span class='hs-layout'>)</span>
  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>10</span><span class='hs-varop'>^</span><span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-str'>"hundred"</span><span class='hs-layout'>)</span>
  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>10</span><span class='hs-varop'>^</span><span class='hs-num'>3</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-str'>"thousand"</span><span class='hs-layout'>)</span>
  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>10</span><span class='hs-varop'>^</span><span class='hs-num'>6</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Number too large"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<p>Beautifying the output is not strictly necessary for the given problem, but makes for a more useful general function.</p><pre><span class='hs-definition'>formatSentence</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<span class='hs-definition'>formatSentence</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>++</span> <span class='hs-str'>" and "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>y</span>
<span class='hs-definition'>formatSentence</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>++</span> <span class='hs-str'>", "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>formatSentence</span> <span class='hs-varid'>xs</span>
</pre>
<p>The algorithm works backwards through the known ranges accumulating fragments for each, before joining them together to make a sentence.</p><pre><span class='hs-definition'>numberToWords</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>makeSentence</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>formatRange</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>ranges</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>makeSentence</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>formatSentence</span> <span class='hs-varop'>.</span> <span class='hs-varid'>reverse</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span>
    <span class='hs-varid'>formatRange</span> <span class='hs-layout'>(</span><span class='hs-varid'>min</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>remainder</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>remainder</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>min</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>major</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>minor</span><span class='hs-layout'>)</span>
      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>remainder</span><span class='hs-layout'>)</span>
      <span class='hs-keyword'>where</span>
        <span class='hs-layout'>(</span><span class='hs-varid'>major</span><span class='hs-layout'>,</span> <span class='hs-varid'>minor</span><span class='hs-layout'>)</span>
          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>min</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>remainder</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quotRem</span> <span class='hs-varid'>remainder</span> <span class='hs-varid'>min</span>
</pre>
<p>For the solution to the problem, it is necessary to strip out spaces and punctuation from the general algorithm.</p><pre><span class='hs-definition'>euler17</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varop'>.</span> <span class='hs-varid'>onlyAlpha</span> <span class='hs-varop'>.</span> <span class='hs-varid'>numberToWords</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>enumFromTo</span> <span class='hs-num'>1</span>
 <span class='hs-keyword'>where</span>
   <span class='hs-varid'>onlyAlpha</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-varid'>elem</span> <span class='hs-keyglyph'>[</span><span class='hs-chr'>'a'</span><span class='hs-keyglyph'>..</span><span class='hs-chr'>'z'</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>tests17</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#17 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>19</span>    <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler17</span> <span class='hs-num'>5</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#17 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>21124</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler17</span> <span class='hs-num'>1000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-18">Problem 18</h2><blockquote><p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.</p></blockquote><pre><span class='hs-definition'>smallInput18</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-str'>"3 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"7 4 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"2 4 6 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"8 5 9 3 "</span>
</pre>
<blockquote><p>That is, 3 + 7 + 4 + 9 = 23.</p><p>Find the maximum total from top to bottom of the larger triangle below.</p></blockquote><pre><span class='hs-definition'>largeInput18</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-str'>"75 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"95 64 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"17 47 82 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"18 35 87 10 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"20 04 82 47 65 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"19 01 23 75 03 34 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"88 02 77 73 07 63 67 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"99 65 04 28 06 16 70 92 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"41 41 26 56 83 40 80 70 33 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"41 48 72 33 47 32 37 16 94 29 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"53 71 44 65 25 43 91 52 97 51 14 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"70 11 33 28 77 73 17 78 39 68 17 57 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"91 71 52 38 17 14 91 43 58 50 27 29 48 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"63 66 04 68 89 53 67 30 73 16 69 87 40 31 "</span> <span class='hs-varop'>++</span>
  <span class='hs-str'>"04 62 98 27 23 09 70 98 73 93 38 53 60 04 23 "</span>
</pre>
<p>Starting at the bottom of the triangle, match the largest of each pair of numbers to its parent. For the test input, this will be:</p><pre><code>[(9, 6), (9, 4), (8, 2)]
</code></pre><p>Summing the two gives the maximum total of this path, so it can be used to replace the second bottom row. Continue folding the bottom row in until only one row of one number remains. This will be the maximum total.</p><pre><span class='hs-definition'>euler18</span> <span class='hs-varid'>h</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldl1'</span> <span class='hs-varid'>maxPath</span> <span class='hs-varop'>.</span> <span class='hs-varid'>parse</span> <span class='hs-varid'>h</span> <span class='hs-varid'>w</span>
 <span class='hs-keyword'>where</span>
   <span class='hs-varid'>maxPath</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>ts</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith3</span> <span class='hs-varid'>addMax</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
   <span class='hs-varid'>addMax</span> <span class='hs-varid'>t</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>b2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-varid'>max</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>b2</span><span class='hs-layout'>)</span>
</pre>
<p>To parse the input, read in as sequence integers then chunk it with a descending width. To enable a nice functional style the input is reversed before being chunked. This has the effect of mirroring the triangle, but this has no bearing on the solution.</p><pre>   <span class='hs-varid'>parse</span> <span class='hs-varid'>h</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>triangleChunk</span> <span class='hs-varid'>h</span> <span class='hs-varop'>.</span> <span class='hs-varid'>reverse</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>stringToInt</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>chunk</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span>
</pre>


<pre>   <span class='hs-varid'>triangleChunk</span> <span class='hs-num'>0</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
   <span class='hs-varid'>triangleChunk</span> <span class='hs-varid'>n</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>take</span> <span class='hs-varid'>n</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>triangleChunk</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>tests18</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#18 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>23</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler18</span> <span class='hs-num'>4</span> <span class='hs-num'>2</span> <span class='hs-varid'>smallInput18</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#18 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>1074</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler18</span> <span class='hs-num'>15</span> <span class='hs-num'>3</span> <span class='hs-varid'>largeInput18</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-19">Problem 19</h2><blockquote><p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p></blockquote><p>Define a data type <code>Month</code> that allows interation over all months in a range. This is overkill for this problem, but allows a chance to investigate Haskell’s type system.</p><p>A <code>Month</code> is composed of a year and a month.</p><pre><span class='hs-keyword'>data</span> <span class='hs-conid'>Month</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Month</span> <span class='hs-conid'>Integer</span> <span class='hs-conid'>Int</span>
</pre>
<p>Provide a conversion to the built-in type <code>Day</code> that returns the first day of the month.</p><pre><span class='hs-definition'>toDay</span> <span class='hs-layout'>(</span><span class='hs-conid'>Month</span> <span class='hs-varid'>y</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromGregorian</span> <span class='hs-varid'>y</span> <span class='hs-varid'>m</span> <span class='hs-num'>1</span>
</pre>
<p>For display, match the format of <code>Day</code> but with days truncated.</p><pre><span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>Month</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-conid'>Month</span> <span class='hs-varid'>y</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>y</span> <span class='hs-varop'>++</span> <span class='hs-str'>"-"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>show</span> <span class='hs-varid'>m</span>
</pre>
<p>Map months to a contiguous range of integers. This is the minimal required definition of <code>Enum</code> that will allow the use of <code>Month</code> in ranges.</p><pre><span class='hs-keyword'>instance</span> <span class='hs-conid'>Enum</span> <span class='hs-conid'>Month</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>fromEnum</span> <span class='hs-layout'>(</span><span class='hs-conid'>Month</span> <span class='hs-varid'>y</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromInteger</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-num'>12</span> <span class='hs-varop'>+</span> <span class='hs-varid'>m</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span>
  <span class='hs-varid'>toEnum</span> <span class='hs-varid'>x</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Month</span> <span class='hs-layout'>(</span><span class='hs-varid'>toInteger</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
    <span class='hs-keyword'>where</span>
      <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quotRem</span> <span class='hs-varid'>x</span> <span class='hs-num'>12</span>
</pre>
<p><code>sundayStartWeek</code> returns the day of the week as the second element of a tuple, which is used to answer the problem.</p><pre><span class='hs-definition'>euler19</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varop'>.</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sundayStartWeek</span> <span class='hs-varop'>.</span> <span class='hs-varid'>toDay</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>tests19</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#19 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>171</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler19</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Month</span> <span class='hs-num'>1901</span> <span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-conid'>Month</span> <span class='hs-num'>2000</span> <span class='hs-num'>12</span><span class='hs-keyglyph'>]</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-20">Problem 20</h2><blockquote><p><i>n</i>! means <i>n</i> × (<i>n</i> - 1) × … × 3 × 2 × 1</p><p>For example, 10! = 10 × 9 × … × 3 × 2 × 1 = 3628800, and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.</p><p>Find the sum of the digits in the number 100!</p></blockquote><p>As with problem 16, this is trivial.</p><pre><span class='hs-definition'>factorial</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>product</span> <span class='hs-varop'>.</span> <span class='hs-varid'>enumFromTo</span> <span class='hs-num'>1</span>
</pre>


<pre><span class='hs-definition'>euler20</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sumOfDigits</span> <span class='hs-varop'>.</span> <span class='hs-varid'>factorial</span>
</pre>


<pre><span class='hs-definition'>tests20</span> <span class='hs-keyglyph'>=</span>
 <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#20 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>648</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler20</span> <span class='hs-num'>100</span>
 <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-21">Problem 21</h2><blockquote><p>Let <i>d</i>(<i>n</i>) be defined as the sum of proper divisors of <i>n</i> (numbers less than <i>n</i> which divide evenly into <i>n</i>). If <i>d</i>(<i>a</i>) = <i>b</i> and <i>d</i>(<i>b</i>) = <i>a</i>, where <i>a</i> != <i>b</i>, then <i>a</i> and <i>b</i> are an amicable pair and each of <i>a</i> and <i>b</i> are called amicable numbers.</p><p>For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.</p><p>Evaluate the sum of all the amicable numbers under 10000.</p></blockquote><p>A function for calculating prime factors was formulated in problem 12. Multiplying out all combinations of these factors gives all possible divisors.</p><pre><span class='hs-definition'>divisors</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>product</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>combinations</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>group</span> <span class='hs-varop'>.</span> <span class='hs-varid'>primeFactors</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>combinations</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>concat</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tails</span> <span class='hs-varid'>ys</span><span class='hs-keyglyph'>]</span>
</pre>
<p>The <code>divisors</code> function is guaranteed to always place <i>n</i> at the top of the list, since <code>tails</code> returns the largest sublist first.</p><pre><span class='hs-definition'>properDivisors</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail</span> <span class='hs-varop'>.</span> <span class='hs-varid'>divisors</span>
</pre>
<p>A special case is required for 1, since it has no proper divisors.</p><pre><span class='hs-definition'>amiacable</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-definition'>amiacable</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-varop'>==</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>a</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>b</span>
  <span class='hs-keyword'>where</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span> <span class='hs-varid'>n</span>
        <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span> <span class='hs-varid'>a</span>
        <span class='hs-varid'>d</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>properDivisors</span>
</pre>


<pre><span class='hs-definition'>euler21</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>amiacable</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>tests21</span> <span class='hs-keyglyph'>=</span>
 <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#21 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>31626</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler21</span> <span class='hs-num'>10000</span>
 <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-22">Problem 22</h2><blockquote><p>Using <code>names.txt</code>, a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.</p><p>For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938<sup>th</sup> name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.</p><p>What is the total of all the name scores in the file?</p></blockquote><p>The word scoring function takes advantage of all the names being uppercase A-Z, though any different alphabet could be substituted easily. This is not the most efficient algorithm since scoring a character is O(<i>n</i>), but is sufficient for this problem. It could easily be improved by using a lookup table, or O(1) if the ordinal values of the letters were used.</p><pre><span class='hs-definition'>scoreWord</span> <span class='hs-varid'>index</span> <span class='hs-varid'>word</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>index</span> <span class='hs-varop'>*</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>scoreChar</span> <span class='hs-varid'>word</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>alphabet</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-chr'>'A'</span><span class='hs-keyglyph'>..</span><span class='hs-chr'>'Z'</span><span class='hs-keyglyph'>]</span>
    <span class='hs-varid'>scoreChar</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>elemIndex</span> <span class='hs-varid'>x</span> <span class='hs-varid'>alphabet</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
</pre>


<pre><span class='hs-definition'>scoreArray</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>.</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>scoreWord</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sort</span>
</pre>


<pre><span class='hs-definition'>euler22</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scoreArray</span> <span class='hs-varop'>.</span> <span class='hs-varid'>parse</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>parse</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varop'>.</span> <span class='hs-varid'>init</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>splitOn</span> <span class='hs-str'>","</span><span class='hs-layout'>)</span>
</pre>
<p>This is the first problem to require input from an external file. Due to Haskell’s functional nature, this needs to be passed in from the external main function.</p><pre><span class='hs-definition'>tests22</span> <span class='hs-varid'>input</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#22 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>871198282</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler22</span> <span class='hs-varid'>input</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-23">Problem 23</h2><blockquote><p>A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.</p><p>As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.</p><p>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p></blockquote><p>A function to testing abundance of a number can be built from the <code>properDivisors</code> function defined in problem 21.</p><pre><span class='hs-definition'>abundant</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<span class='hs-definition'>abundant</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>properDivisors</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>y</span>
</pre>
<p>Rather than enumerating all pairs of abundants that could potentially sum to <i>n</i>, it is easier and cheaper to enumerate all pairs of numbers that sum to <i>n</i> and check whether they are abundant.</p><pre><span class='hs-definition'>sumOf2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>or</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>quot</span> <span class='hs-varid'>n</span> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><span class='hs-definition'>euler23</span> <span class='hs-varid'>bound</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sumOf2</span> <span class='hs-varid'>abundant'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-keyglyph'>..</span><span class='hs-varid'>bound</span><span class='hs-keyglyph'>]</span>
  <span class='hs-keyword'>where</span>
</pre>
<p>Memoization is desirable on <code>abundant</code> because it is an expensive function, and will be called many times with the same input from a small domain.</p><pre>    <span class='hs-varid'>abundant'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Memo</span><span class='hs-varop'>.</span><span class='hs-varid'>arrayRange</span><span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-varid'>bound</span><span class='hs-layout'>)</span> <span class='hs-varid'>abundant</span>
</pre>


<pre><span class='hs-definition'>tests23</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#23 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>4179871</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler23</span> <span class='hs-num'>28123</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-24">Problem 24</h2><blockquote><p>A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:</p><p>012, 021, 102, 120, 201, 210</p><p>What is the millionth lexicographic permutation of the digits 0 to 9?</p></blockquote><p>Haskell provides a built in <code>permutations</code> function, but it is not in lexical order. List comprehensions can be used to build a new version.</p><pre><span class='hs-definition'>lexicalPermutations</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>lexicalPermutations</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>ys</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span>
                                 <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lexicalPermutations</span> <span class='hs-layout'>(</span><span class='hs-varid'>delete</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
</pre>
<p>There is a potential off-by-one error lurking here: the sixth permutation is at index five in the list.</p><pre><span class='hs-definition'>euler24</span> <span class='hs-varid'>range</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>intToDigit</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lexicalPermutations</span> <span class='hs-varid'>range</span> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>tests24</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#24 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-str'>"210"</span>        <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler24</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-num'>2</span><span class='hs-keyglyph'>]</span> <span class='hs-num'>6</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#24 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-str'>"2783915460"</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler24</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-num'>9</span><span class='hs-keyglyph'>]</span> <span class='hs-num'>1000000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="problem-25">Problem 25</h2><blockquote><p>The Fibonacci sequence is defined by the recurrence relation:</p><p>F<sub>n</sub> = F<sub>n</sub>1 + F<sub>n</sub>2, where F<sub>1</sub> = 1 and F<sub>2</sub> = 1.</p><p>The 12<sup>th</sup> term, F<sub>12</sub>, is the first term to contain three digits. What is the first term in the Fibonacci sequence to contain 1000 digits?</p></blockquote><p>The <code>fibonacci</code> method defined in problem 2 has a different starting index than this problem requires, hence the prefixed digits.</p><pre><span class='hs-definition'>euler25</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varop'>$</span> <span class='hs-varid'>takeWhile</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;</span> <span class='hs-num'>10</span><span class='hs-varop'>^</span><span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-conop'>:</span><span class='hs-num'>1</span><span class='hs-conop'>:</span><span class='hs-varid'>fibonacci</span><span class='hs-layout'>)</span>
</pre>


<pre><span class='hs-definition'>tests25</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyglyph'>[</span> <span class='hs-str'>"#25 given"</span>   <span class='hs-varop'>~:</span> <span class='hs-num'>12</span>   <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler25</span> <span class='hs-num'>3</span>
  <span class='hs-layout'>,</span> <span class='hs-str'>"#25 problem"</span> <span class='hs-varop'>~:</span> <span class='hs-num'>4782</span> <span class='hs-varop'>~=?</span> <span class='hs-varid'>euler25</span> <span class='hs-num'>1000</span>
  <span class='hs-keyglyph'>]</span>
</pre>
<h2 id="postamble">Postamble</h2><p>There are over three hundred and fifty problems current on Project Euler, and I have as yet tackled but a small sample of them here. In time, I hope to extend this document further with more solutions. There is still plenty more Haskell for me to learn. I haven’t even started on monads!</p><p>As a final and closing convenience, a main function is provided to run all the given test cases.</p><pre><span class='hs-definition'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
  <span class='hs-varid'>input22</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readFile</span> <span class='hs-str'>"data/names.txt"</span>
  <span class='hs-varid'>runTestTT</span> <span class='hs-varop'>$</span> <span class='hs-conid'>TestList</span> <span class='hs-layout'>(</span> <span class='hs-varid'>tests1</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests2</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests3</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests4</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests5</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests6</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests7</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests8</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests9</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests10</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests11</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests12</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests13</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests14</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests15</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests16</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests17</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests18</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests19</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests20</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests21</span>
                      <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-varid'>tests22</span> <span class='hs-varid'>input22</span><span class='hs-layout'>)</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests23</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests24</span>
                      <span class='hs-varop'>++</span> <span class='hs-varid'>tests25</span>
                      <span class='hs-layout'>)</span>
</pre>
<h2 id="acknowledgements">Acknowledgements</h2><p>The styling for this document is from Kevin Burke’s excellent <a href="http://kevinburke.bitbucket.org/markdowncss/">Markdown CSS</a>. I am grateful to Thomas Sutton for his <a href="http://passingcuriosity.com/2008/literate-haskell-with-markdown-syntax-hightlighting/">formatting Literate Haskell blog post</a>, that inspired the build scripts I made for this project. Many solutions were refined after-the-fact by suggestions gleaned from other solutions in the Project Euler forums.</p>
</body>
</html>
